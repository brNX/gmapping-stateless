// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protobuf/particle_reading.proto

#ifndef PROTOBUF_protobuf_2fparticle_5freading_2eproto__INCLUDED
#define PROTOBUF_protobuf_2fparticle_5freading_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace gmapping_structs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();

class Workpackage;
class WorkResponse;
class Particle;
class ScanMatcherMap;
class OrientedPoint;
class PointAccumulator;
class Array2D;
class Array2D_innerType;
class Autoptr;
class HierarchicalArray2D;
class HierarchicalArray2D_innerType;
class IntPoint;

// ===================================================================

class Workpackage : public ::google::protobuf::Message {
 public:
  Workpackage();
  virtual ~Workpackage();
  
  Workpackage(const Workpackage& from);
  
  inline Workpackage& operator=(const Workpackage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Workpackage& default_instance();
  
  void Swap(Workpackage* other);
  
  // implements Message ----------------------------------------------
  
  Workpackage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Workpackage& from);
  void MergeFrom(const Workpackage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gmapping_structs.Particle particle = 1;
  inline bool has_particle() const;
  inline void clear_particle();
  static const int kParticleFieldNumber = 1;
  inline const ::gmapping_structs::Particle& particle() const;
  inline ::gmapping_structs::Particle* mutable_particle();
  inline ::gmapping_structs::Particle* release_particle();
  
  // repeated double plainreading = 2 [packed = true];
  inline int plainreading_size() const;
  inline void clear_plainreading();
  static const int kPlainreadingFieldNumber = 2;
  inline double plainreading(int index) const;
  inline void set_plainreading(int index, double value);
  inline void add_plainreading(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      plainreading() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_plainreading();
  
  // required bool activeAreaComputed = 3;
  inline bool has_activeareacomputed() const;
  inline void clear_activeareacomputed();
  static const int kActiveAreaComputedFieldNumber = 3;
  inline bool activeareacomputed() const;
  inline void set_activeareacomputed(bool value);
  
  // required double angularOdometryReliability = 4;
  inline bool has_angularodometryreliability() const;
  inline void clear_angularodometryreliability();
  static const int kAngularOdometryReliabilityFieldNumber = 4;
  inline double angularodometryreliability() const;
  inline void set_angularodometryreliability(double value);
  
  // required double enlargeStep = 5;
  inline bool has_enlargestep() const;
  inline void clear_enlargestep();
  static const int kEnlargeStepFieldNumber = 5;
  inline double enlargestep() const;
  inline void set_enlargestep(double value);
  
  // required double freeCellRatio = 6;
  inline bool has_freecellratio() const;
  inline void clear_freecellratio();
  static const int kFreeCellRatioFieldNumber = 6;
  inline double freecellratio() const;
  inline void set_freecellratio(double value);
  
  // required double fullnessThreshold = 7;
  inline bool has_fullnessthreshold() const;
  inline void clear_fullnessthreshold();
  static const int kFullnessThresholdFieldNumber = 7;
  inline double fullnessthreshold() const;
  inline void set_fullnessthreshold(double value);
  
  // required double gaussianSigma = 8;
  inline bool has_gaussiansigma() const;
  inline void clear_gaussiansigma();
  static const int kGaussianSigmaFieldNumber = 8;
  inline double gaussiansigma() const;
  inline void set_gaussiansigma(double value);
  
  // required bool generateMap = 9;
  inline bool has_generatemap() const;
  inline void clear_generatemap();
  static const int kGenerateMapFieldNumber = 9;
  inline bool generatemap() const;
  inline void set_generatemap(bool value);
  
  // required uint32 initialBeamSkip = 10;
  inline bool has_initialbeamskip() const;
  inline void clear_initialbeamskip();
  static const int kInitialBeamSkipFieldNumber = 10;
  inline ::google::protobuf::uint32 initialbeamskip() const;
  inline void set_initialbeamskip(::google::protobuf::uint32 value);
  
  // required int32 kernelSize = 11;
  inline bool has_kernelsize() const;
  inline void clear_kernelsize();
  static const int kKernelSizeFieldNumber = 11;
  inline ::google::protobuf::int32 kernelsize() const;
  inline void set_kernelsize(::google::protobuf::int32 value);
  
  // required double lasamplerange = 12;
  inline bool has_lasamplerange() const;
  inline void clear_lasamplerange();
  static const int kLasamplerangeFieldNumber = 12;
  inline double lasamplerange() const;
  inline void set_lasamplerange(double value);
  
  // required double lasamplestep = 13;
  inline bool has_lasamplestep() const;
  inline void clear_lasamplestep();
  static const int kLasamplestepFieldNumber = 13;
  inline double lasamplestep() const;
  inline void set_lasamplestep(double value);
  
  // repeated double laserAngles = 14 [packed = true];
  inline int laserangles_size() const;
  inline void clear_laserangles();
  static const int kLaserAnglesFieldNumber = 14;
  inline double laserangles(int index) const;
  inline void set_laserangles(int index, double value);
  inline void add_laserangles(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      laserangles() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_laserangles();
  
  // required uint32 laserBeams = 15;
  inline bool has_laserbeams() const;
  inline void clear_laserbeams();
  static const int kLaserBeamsFieldNumber = 15;
  inline ::google::protobuf::uint32 laserbeams() const;
  inline void set_laserbeams(::google::protobuf::uint32 value);
  
  // required double laserMaxRange = 16;
  inline bool has_lasermaxrange() const;
  inline void clear_lasermaxrange();
  static const int kLaserMaxRangeFieldNumber = 16;
  inline double lasermaxrange() const;
  inline void set_lasermaxrange(double value);
  
  // required .gmapping_structs.OrientedPoint laserPose = 17;
  inline bool has_laserpose() const;
  inline void clear_laserpose();
  static const int kLaserPoseFieldNumber = 17;
  inline const ::gmapping_structs::OrientedPoint& laserpose() const;
  inline ::gmapping_structs::OrientedPoint* mutable_laserpose();
  inline ::gmapping_structs::OrientedPoint* release_laserpose();
  
  // required double likelihoodSigma = 18;
  inline bool has_likelihoodsigma() const;
  inline void clear_likelihoodsigma();
  static const int kLikelihoodSigmaFieldNumber = 18;
  inline double likelihoodsigma() const;
  inline void set_likelihoodsigma(double value);
  
  // required uint32 likelihoodSkip = 19;
  inline bool has_likelihoodskip() const;
  inline void clear_likelihoodskip();
  static const int kLikelihoodSkipFieldNumber = 19;
  inline ::google::protobuf::uint32 likelihoodskip() const;
  inline void set_likelihoodskip(::google::protobuf::uint32 value);
  
  // required double linearOdometryReliability = 20;
  inline bool has_linearodometryreliability() const;
  inline void clear_linearodometryreliability();
  static const int kLinearOdometryReliabilityFieldNumber = 20;
  inline double linearodometryreliability() const;
  inline void set_linearodometryreliability(double value);
  
  // required double llsamplerange = 21;
  inline bool has_llsamplerange() const;
  inline void clear_llsamplerange();
  static const int kLlsamplerangeFieldNumber = 21;
  inline double llsamplerange() const;
  inline void set_llsamplerange(double value);
  
  // required double llsamplestep = 22;
  inline bool has_llsamplestep() const;
  inline void clear_llsamplestep();
  static const int kLlsamplestepFieldNumber = 22;
  inline double llsamplestep() const;
  inline void set_llsamplestep(double value);
  
  // required double optAngularDelta = 23;
  inline bool has_optangulardelta() const;
  inline void clear_optangulardelta();
  static const int kOptAngularDeltaFieldNumber = 23;
  inline double optangulardelta() const;
  inline void set_optangulardelta(double value);
  
  // required double optLinearDelta = 24;
  inline bool has_optlineardelta() const;
  inline void clear_optlineardelta();
  static const int kOptLinearDeltaFieldNumber = 24;
  inline double optlineardelta() const;
  inline void set_optlineardelta(double value);
  
  // required uint32 optRecursiveIterations = 25;
  inline bool has_optrecursiveiterations() const;
  inline void clear_optrecursiveiterations();
  static const int kOptRecursiveIterationsFieldNumber = 25;
  inline ::google::protobuf::uint32 optrecursiveiterations() const;
  inline void set_optrecursiveiterations(::google::protobuf::uint32 value);
  
  // required double usableRange = 26;
  inline bool has_usablerange() const;
  inline void clear_usablerange();
  static const int kUsableRangeFieldNumber = 26;
  inline double usablerange() const;
  inline void set_usablerange(double value);
  
  // required double minimumScore = 27;
  inline bool has_minimumscore() const;
  inline void clear_minimumscore();
  static const int kMinimumScoreFieldNumber = 27;
  inline double minimumscore() const;
  inline void set_minimumscore(double value);
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.Workpackage)
 private:
  inline void set_has_particle();
  inline void clear_has_particle();
  inline void set_has_activeareacomputed();
  inline void clear_has_activeareacomputed();
  inline void set_has_angularodometryreliability();
  inline void clear_has_angularodometryreliability();
  inline void set_has_enlargestep();
  inline void clear_has_enlargestep();
  inline void set_has_freecellratio();
  inline void clear_has_freecellratio();
  inline void set_has_fullnessthreshold();
  inline void clear_has_fullnessthreshold();
  inline void set_has_gaussiansigma();
  inline void clear_has_gaussiansigma();
  inline void set_has_generatemap();
  inline void clear_has_generatemap();
  inline void set_has_initialbeamskip();
  inline void clear_has_initialbeamskip();
  inline void set_has_kernelsize();
  inline void clear_has_kernelsize();
  inline void set_has_lasamplerange();
  inline void clear_has_lasamplerange();
  inline void set_has_lasamplestep();
  inline void clear_has_lasamplestep();
  inline void set_has_laserbeams();
  inline void clear_has_laserbeams();
  inline void set_has_lasermaxrange();
  inline void clear_has_lasermaxrange();
  inline void set_has_laserpose();
  inline void clear_has_laserpose();
  inline void set_has_likelihoodsigma();
  inline void clear_has_likelihoodsigma();
  inline void set_has_likelihoodskip();
  inline void clear_has_likelihoodskip();
  inline void set_has_linearodometryreliability();
  inline void clear_has_linearodometryreliability();
  inline void set_has_llsamplerange();
  inline void clear_has_llsamplerange();
  inline void set_has_llsamplestep();
  inline void clear_has_llsamplestep();
  inline void set_has_optangulardelta();
  inline void clear_has_optangulardelta();
  inline void set_has_optlineardelta();
  inline void clear_has_optlineardelta();
  inline void set_has_optrecursiveiterations();
  inline void clear_has_optrecursiveiterations();
  inline void set_has_usablerange();
  inline void clear_has_usablerange();
  inline void set_has_minimumscore();
  inline void clear_has_minimumscore();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gmapping_structs::Particle* particle_;
  ::google::protobuf::RepeatedField< double > plainreading_;
  mutable int _plainreading_cached_byte_size_;
  double angularodometryreliability_;
  double enlargestep_;
  double freecellratio_;
  double fullnessthreshold_;
  bool activeareacomputed_;
  bool generatemap_;
  ::google::protobuf::uint32 initialbeamskip_;
  double gaussiansigma_;
  double lasamplerange_;
  double lasamplestep_;
  ::google::protobuf::int32 kernelsize_;
  ::google::protobuf::uint32 laserbeams_;
  ::google::protobuf::RepeatedField< double > laserangles_;
  mutable int _laserangles_cached_byte_size_;
  double lasermaxrange_;
  ::gmapping_structs::OrientedPoint* laserpose_;
  double likelihoodsigma_;
  double linearodometryreliability_;
  double llsamplerange_;
  double llsamplestep_;
  ::google::protobuf::uint32 likelihoodskip_;
  ::google::protobuf::uint32 optrecursiveiterations_;
  double optangulardelta_;
  double optlineardelta_;
  double usablerange_;
  double minimumscore_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static Workpackage* default_instance_;
};
// -------------------------------------------------------------------

class WorkResponse : public ::google::protobuf::Message {
 public:
  WorkResponse();
  virtual ~WorkResponse();
  
  WorkResponse(const WorkResponse& from);
  
  inline WorkResponse& operator=(const WorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkResponse& default_instance();
  
  void Swap(WorkResponse* other);
  
  // implements Message ----------------------------------------------
  
  WorkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkResponse& from);
  void MergeFrom(const WorkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // repeated .gmapping_structs.IntPoint m_activeArea = 2;
  inline int m_activearea_size() const;
  inline void clear_m_activearea();
  static const int kMActiveAreaFieldNumber = 2;
  inline const ::gmapping_structs::IntPoint& m_activearea(int index) const;
  inline ::gmapping_structs::IntPoint* mutable_m_activearea(int index);
  inline ::gmapping_structs::IntPoint* add_m_activearea();
  inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >&
      m_activearea() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >*
      mutable_m_activearea();
  
  // required double weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline double weight() const;
  inline void set_weight(double value);
  
  // required double weightSum = 4;
  inline bool has_weightsum() const;
  inline void clear_weightsum();
  static const int kWeightSumFieldNumber = 4;
  inline double weightsum() const;
  inline void set_weightsum(double value);
  
  // required .gmapping_structs.OrientedPoint pose = 5;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 5;
  inline const ::gmapping_structs::OrientedPoint& pose() const;
  inline ::gmapping_structs::OrientedPoint* mutable_pose();
  inline ::gmapping_structs::OrientedPoint* release_pose();
  
  // optional double minx = 6;
  inline bool has_minx() const;
  inline void clear_minx();
  static const int kMinxFieldNumber = 6;
  inline double minx() const;
  inline void set_minx(double value);
  
  // optional double miny = 7;
  inline bool has_miny() const;
  inline void clear_miny();
  static const int kMinyFieldNumber = 7;
  inline double miny() const;
  inline void set_miny(double value);
  
  // optional double maxx = 8;
  inline bool has_maxx() const;
  inline void clear_maxx();
  static const int kMaxxFieldNumber = 8;
  inline double maxx() const;
  inline void set_maxx(double value);
  
  // optional double maxy = 9;
  inline bool has_maxy() const;
  inline void clear_maxy();
  static const int kMaxyFieldNumber = 9;
  inline double maxy() const;
  inline void set_maxy(double value);
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.WorkResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_weightsum();
  inline void clear_has_weightsum();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_minx();
  inline void clear_has_minx();
  inline void set_has_miny();
  inline void clear_has_miny();
  inline void set_has_maxx();
  inline void clear_has_maxx();
  inline void set_has_maxy();
  inline void clear_has_maxy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint > m_activearea_;
  double weight_;
  double weightsum_;
  ::gmapping_structs::OrientedPoint* pose_;
  double minx_;
  double miny_;
  double maxx_;
  double maxy_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static WorkResponse* default_instance_;
};
// -------------------------------------------------------------------

class Particle : public ::google::protobuf::Message {
 public:
  Particle();
  virtual ~Particle();
  
  Particle(const Particle& from);
  
  inline Particle& operator=(const Particle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Particle& default_instance();
  
  void Swap(Particle* other);
  
  // implements Message ----------------------------------------------
  
  Particle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Particle& from);
  void MergeFrom(const Particle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required double weightSum = 2;
  inline bool has_weightsum() const;
  inline void clear_weightsum();
  static const int kWeightSumFieldNumber = 2;
  inline double weightsum() const;
  inline void set_weightsum(double value);
  
  // required double weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline double weight() const;
  inline void set_weight(double value);
  
  // required .gmapping_structs.ScanMatcherMap smap = 4;
  inline bool has_smap() const;
  inline void clear_smap();
  static const int kSmapFieldNumber = 4;
  inline const ::gmapping_structs::ScanMatcherMap& smap() const;
  inline ::gmapping_structs::ScanMatcherMap* mutable_smap();
  inline ::gmapping_structs::ScanMatcherMap* release_smap();
  
  // required .gmapping_structs.OrientedPoint pose = 5;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 5;
  inline const ::gmapping_structs::OrientedPoint& pose() const;
  inline ::gmapping_structs::OrientedPoint* mutable_pose();
  inline ::gmapping_structs::OrientedPoint* release_pose();
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.Particle)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_weightsum();
  inline void clear_has_weightsum();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_smap();
  inline void clear_has_smap();
  inline void set_has_pose();
  inline void clear_has_pose();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double weightsum_;
  double weight_;
  ::gmapping_structs::ScanMatcherMap* smap_;
  ::gmapping_structs::OrientedPoint* pose_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static Particle* default_instance_;
};
// -------------------------------------------------------------------

class ScanMatcherMap : public ::google::protobuf::Message {
 public:
  ScanMatcherMap();
  virtual ~ScanMatcherMap();
  
  ScanMatcherMap(const ScanMatcherMap& from);
  
  inline ScanMatcherMap& operator=(const ScanMatcherMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanMatcherMap& default_instance();
  
  void Swap(ScanMatcherMap* other);
  
  // implements Message ----------------------------------------------
  
  ScanMatcherMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanMatcherMap& from);
  void MergeFrom(const ScanMatcherMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double m_center_x = 1;
  inline bool has_m_center_x() const;
  inline void clear_m_center_x();
  static const int kMCenterXFieldNumber = 1;
  inline double m_center_x() const;
  inline void set_m_center_x(double value);
  
  // required double m_center_y = 2;
  inline bool has_m_center_y() const;
  inline void clear_m_center_y();
  static const int kMCenterYFieldNumber = 2;
  inline double m_center_y() const;
  inline void set_m_center_y(double value);
  
  // required double m_worldSizeX = 3;
  inline bool has_m_worldsizex() const;
  inline void clear_m_worldsizex();
  static const int kMWorldSizeXFieldNumber = 3;
  inline double m_worldsizex() const;
  inline void set_m_worldsizex(double value);
  
  // required double m_worldSizeY = 4;
  inline bool has_m_worldsizey() const;
  inline void clear_m_worldsizey();
  static const int kMWorldSizeYFieldNumber = 4;
  inline double m_worldsizey() const;
  inline void set_m_worldsizey(double value);
  
  // required double m_delta = 5;
  inline bool has_m_delta() const;
  inline void clear_m_delta();
  static const int kMDeltaFieldNumber = 5;
  inline double m_delta() const;
  inline void set_m_delta(double value);
  
  // required int32 m_mapSizeX = 6;
  inline bool has_m_mapsizex() const;
  inline void clear_m_mapsizex();
  static const int kMMapSizeXFieldNumber = 6;
  inline ::google::protobuf::int32 m_mapsizex() const;
  inline void set_m_mapsizex(::google::protobuf::int32 value);
  
  // required int32 m_mapSizeY = 7;
  inline bool has_m_mapsizey() const;
  inline void clear_m_mapsizey();
  static const int kMMapSizeYFieldNumber = 7;
  inline ::google::protobuf::int32 m_mapsizey() const;
  inline void set_m_mapsizey(::google::protobuf::int32 value);
  
  // required int32 m_sizeX2 = 8;
  inline bool has_m_sizex2() const;
  inline void clear_m_sizex2();
  static const int kMSizeX2FieldNumber = 8;
  inline ::google::protobuf::int32 m_sizex2() const;
  inline void set_m_sizex2(::google::protobuf::int32 value);
  
  // required int32 m_sizeY2 = 9;
  inline bool has_m_sizey2() const;
  inline void clear_m_sizey2();
  static const int kMSizeY2FieldNumber = 9;
  inline ::google::protobuf::int32 m_sizey2() const;
  inline void set_m_sizey2(::google::protobuf::int32 value);
  
  // required .gmapping_structs.HierarchicalArray2D m_storage = 10;
  inline bool has_m_storage() const;
  inline void clear_m_storage();
  static const int kMStorageFieldNumber = 10;
  inline const ::gmapping_structs::HierarchicalArray2D& m_storage() const;
  inline ::gmapping_structs::HierarchicalArray2D* mutable_m_storage();
  inline ::gmapping_structs::HierarchicalArray2D* release_m_storage();
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.ScanMatcherMap)
 private:
  inline void set_has_m_center_x();
  inline void clear_has_m_center_x();
  inline void set_has_m_center_y();
  inline void clear_has_m_center_y();
  inline void set_has_m_worldsizex();
  inline void clear_has_m_worldsizex();
  inline void set_has_m_worldsizey();
  inline void clear_has_m_worldsizey();
  inline void set_has_m_delta();
  inline void clear_has_m_delta();
  inline void set_has_m_mapsizex();
  inline void clear_has_m_mapsizex();
  inline void set_has_m_mapsizey();
  inline void clear_has_m_mapsizey();
  inline void set_has_m_sizex2();
  inline void clear_has_m_sizex2();
  inline void set_has_m_sizey2();
  inline void clear_has_m_sizey2();
  inline void set_has_m_storage();
  inline void clear_has_m_storage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double m_center_x_;
  double m_center_y_;
  double m_worldsizex_;
  double m_worldsizey_;
  double m_delta_;
  ::google::protobuf::int32 m_mapsizex_;
  ::google::protobuf::int32 m_mapsizey_;
  ::google::protobuf::int32 m_sizex2_;
  ::google::protobuf::int32 m_sizey2_;
  ::gmapping_structs::HierarchicalArray2D* m_storage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static ScanMatcherMap* default_instance_;
};
// -------------------------------------------------------------------

class OrientedPoint : public ::google::protobuf::Message {
 public:
  OrientedPoint();
  virtual ~OrientedPoint();
  
  OrientedPoint(const OrientedPoint& from);
  
  inline OrientedPoint& operator=(const OrientedPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrientedPoint& default_instance();
  
  void Swap(OrientedPoint* other);
  
  // implements Message ----------------------------------------------
  
  OrientedPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrientedPoint& from);
  void MergeFrom(const OrientedPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // required double theta = 3;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 3;
  inline double theta() const;
  inline void set_theta(double value);
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.OrientedPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_theta();
  inline void clear_has_theta();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  double theta_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static OrientedPoint* default_instance_;
};
// -------------------------------------------------------------------

class PointAccumulator : public ::google::protobuf::Message {
 public:
  PointAccumulator();
  virtual ~PointAccumulator();
  
  PointAccumulator(const PointAccumulator& from);
  
  inline PointAccumulator& operator=(const PointAccumulator& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointAccumulator& default_instance();
  
  void Swap(PointAccumulator* other);
  
  // implements Message ----------------------------------------------
  
  PointAccumulator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointAccumulator& from);
  void MergeFrom(const PointAccumulator& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required int32 n = 3;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 3;
  inline ::google::protobuf::int32 n() const;
  inline void set_n(::google::protobuf::int32 value);
  
  // required int32 visits = 4;
  inline bool has_visits() const;
  inline void clear_visits();
  static const int kVisitsFieldNumber = 4;
  inline ::google::protobuf::int32 visits() const;
  inline void set_visits(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.PointAccumulator)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_visits();
  inline void clear_has_visits();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  ::google::protobuf::int32 n_;
  ::google::protobuf::int32 visits_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static PointAccumulator* default_instance_;
};
// -------------------------------------------------------------------

class Array2D_innerType : public ::google::protobuf::Message {
 public:
  Array2D_innerType();
  virtual ~Array2D_innerType();
  
  Array2D_innerType(const Array2D_innerType& from);
  
  inline Array2D_innerType& operator=(const Array2D_innerType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Array2D_innerType& default_instance();
  
  void Swap(Array2D_innerType* other);
  
  // implements Message ----------------------------------------------
  
  Array2D_innerType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Array2D_innerType& from);
  void MergeFrom(const Array2D_innerType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gmapping_structs.PointAccumulator y = 1;
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 1;
  inline const ::gmapping_structs::PointAccumulator& y(int index) const;
  inline ::gmapping_structs::PointAccumulator* mutable_y(int index);
  inline ::gmapping_structs::PointAccumulator* add_y();
  inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::PointAccumulator >&
      y() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::PointAccumulator >*
      mutable_y();
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.Array2D.innerType)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gmapping_structs::PointAccumulator > y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static Array2D_innerType* default_instance_;
};
// -------------------------------------------------------------------

class Array2D : public ::google::protobuf::Message {
 public:
  Array2D();
  virtual ~Array2D();
  
  Array2D(const Array2D& from);
  
  inline Array2D& operator=(const Array2D& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Array2D& default_instance();
  
  void Swap(Array2D* other);
  
  // implements Message ----------------------------------------------
  
  Array2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Array2D& from);
  void MergeFrom(const Array2D& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Array2D_innerType innerType;
  
  // accessors -------------------------------------------------------
  
  // required int32 m_xsize = 1;
  inline bool has_m_xsize() const;
  inline void clear_m_xsize();
  static const int kMXsizeFieldNumber = 1;
  inline ::google::protobuf::int32 m_xsize() const;
  inline void set_m_xsize(::google::protobuf::int32 value);
  
  // required int32 m_ysize = 2;
  inline bool has_m_ysize() const;
  inline void clear_m_ysize();
  static const int kMYsizeFieldNumber = 2;
  inline ::google::protobuf::int32 m_ysize() const;
  inline void set_m_ysize(::google::protobuf::int32 value);
  
  // repeated .gmapping_structs.Array2D.innerType x = 4;
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline const ::gmapping_structs::Array2D_innerType& x(int index) const;
  inline ::gmapping_structs::Array2D_innerType* mutable_x(int index);
  inline ::gmapping_structs::Array2D_innerType* add_x();
  inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Array2D_innerType >&
      x() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Array2D_innerType >*
      mutable_x();
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.Array2D)
 private:
  inline void set_has_m_xsize();
  inline void clear_has_m_xsize();
  inline void set_has_m_ysize();
  inline void clear_has_m_ysize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 m_xsize_;
  ::google::protobuf::int32 m_ysize_;
  ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Array2D_innerType > x_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static Array2D* default_instance_;
};
// -------------------------------------------------------------------

class Autoptr : public ::google::protobuf::Message {
 public:
  Autoptr();
  virtual ~Autoptr();
  
  Autoptr(const Autoptr& from);
  
  inline Autoptr& operator=(const Autoptr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Autoptr& default_instance();
  
  void Swap(Autoptr* other);
  
  // implements Message ----------------------------------------------
  
  Autoptr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Autoptr& from);
  void MergeFrom(const Autoptr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gmapping_structs.Array2D data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::gmapping_structs::Array2D& data() const;
  inline ::gmapping_structs::Array2D* mutable_data();
  inline ::gmapping_structs::Array2D* release_data();
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.Autoptr)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gmapping_structs::Array2D* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static Autoptr* default_instance_;
};
// -------------------------------------------------------------------

class HierarchicalArray2D_innerType : public ::google::protobuf::Message {
 public:
  HierarchicalArray2D_innerType();
  virtual ~HierarchicalArray2D_innerType();
  
  HierarchicalArray2D_innerType(const HierarchicalArray2D_innerType& from);
  
  inline HierarchicalArray2D_innerType& operator=(const HierarchicalArray2D_innerType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HierarchicalArray2D_innerType& default_instance();
  
  void Swap(HierarchicalArray2D_innerType* other);
  
  // implements Message ----------------------------------------------
  
  HierarchicalArray2D_innerType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HierarchicalArray2D_innerType& from);
  void MergeFrom(const HierarchicalArray2D_innerType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gmapping_structs.Autoptr m_cells_y = 1;
  inline int m_cells_y_size() const;
  inline void clear_m_cells_y();
  static const int kMCellsYFieldNumber = 1;
  inline const ::gmapping_structs::Autoptr& m_cells_y(int index) const;
  inline ::gmapping_structs::Autoptr* mutable_m_cells_y(int index);
  inline ::gmapping_structs::Autoptr* add_m_cells_y();
  inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Autoptr >&
      m_cells_y() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Autoptr >*
      mutable_m_cells_y();
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.HierarchicalArray2D.innerType)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Autoptr > m_cells_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static HierarchicalArray2D_innerType* default_instance_;
};
// -------------------------------------------------------------------

class HierarchicalArray2D : public ::google::protobuf::Message {
 public:
  HierarchicalArray2D();
  virtual ~HierarchicalArray2D();
  
  HierarchicalArray2D(const HierarchicalArray2D& from);
  
  inline HierarchicalArray2D& operator=(const HierarchicalArray2D& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HierarchicalArray2D& default_instance();
  
  void Swap(HierarchicalArray2D* other);
  
  // implements Message ----------------------------------------------
  
  HierarchicalArray2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HierarchicalArray2D& from);
  void MergeFrom(const HierarchicalArray2D& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef HierarchicalArray2D_innerType innerType;
  
  // accessors -------------------------------------------------------
  
  // required int32 m_patchMagnitude = 1;
  inline bool has_m_patchmagnitude() const;
  inline void clear_m_patchmagnitude();
  static const int kMPatchMagnitudeFieldNumber = 1;
  inline ::google::protobuf::int32 m_patchmagnitude() const;
  inline void set_m_patchmagnitude(::google::protobuf::int32 value);
  
  // required int32 m_patchSize = 2;
  inline bool has_m_patchsize() const;
  inline void clear_m_patchsize();
  static const int kMPatchSizeFieldNumber = 2;
  inline ::google::protobuf::int32 m_patchsize() const;
  inline void set_m_patchsize(::google::protobuf::int32 value);
  
  // repeated .gmapping_structs.HierarchicalArray2D.innerType m_cells_x = 3;
  inline int m_cells_x_size() const;
  inline void clear_m_cells_x();
  static const int kMCellsXFieldNumber = 3;
  inline const ::gmapping_structs::HierarchicalArray2D_innerType& m_cells_x(int index) const;
  inline ::gmapping_structs::HierarchicalArray2D_innerType* mutable_m_cells_x(int index);
  inline ::gmapping_structs::HierarchicalArray2D_innerType* add_m_cells_x();
  inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::HierarchicalArray2D_innerType >&
      m_cells_x() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::HierarchicalArray2D_innerType >*
      mutable_m_cells_x();
  
  // required int32 m_xsize = 4;
  inline bool has_m_xsize() const;
  inline void clear_m_xsize();
  static const int kMXsizeFieldNumber = 4;
  inline ::google::protobuf::int32 m_xsize() const;
  inline void set_m_xsize(::google::protobuf::int32 value);
  
  // required int32 m_ysize = 5;
  inline bool has_m_ysize() const;
  inline void clear_m_ysize();
  static const int kMYsizeFieldNumber = 5;
  inline ::google::protobuf::int32 m_ysize() const;
  inline void set_m_ysize(::google::protobuf::int32 value);
  
  // repeated .gmapping_structs.IntPoint m_activeArea = 6;
  inline int m_activearea_size() const;
  inline void clear_m_activearea();
  static const int kMActiveAreaFieldNumber = 6;
  inline const ::gmapping_structs::IntPoint& m_activearea(int index) const;
  inline ::gmapping_structs::IntPoint* mutable_m_activearea(int index);
  inline ::gmapping_structs::IntPoint* add_m_activearea();
  inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >&
      m_activearea() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >*
      mutable_m_activearea();
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.HierarchicalArray2D)
 private:
  inline void set_has_m_patchmagnitude();
  inline void clear_has_m_patchmagnitude();
  inline void set_has_m_patchsize();
  inline void clear_has_m_patchsize();
  inline void set_has_m_xsize();
  inline void clear_has_m_xsize();
  inline void set_has_m_ysize();
  inline void clear_has_m_ysize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 m_patchmagnitude_;
  ::google::protobuf::int32 m_patchsize_;
  ::google::protobuf::RepeatedPtrField< ::gmapping_structs::HierarchicalArray2D_innerType > m_cells_x_;
  ::google::protobuf::int32 m_xsize_;
  ::google::protobuf::int32 m_ysize_;
  ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint > m_activearea_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static HierarchicalArray2D* default_instance_;
};
// -------------------------------------------------------------------

class IntPoint : public ::google::protobuf::Message {
 public:
  IntPoint();
  virtual ~IntPoint();
  
  IntPoint(const IntPoint& from);
  
  inline IntPoint& operator=(const IntPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntPoint& default_instance();
  
  void Swap(IntPoint* other);
  
  // implements Message ----------------------------------------------
  
  IntPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntPoint& from);
  void MergeFrom(const IntPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:gmapping_structs.IntPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fparticle_5freading_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fparticle_5freading_2eproto();
  
  void InitAsDefaultInstance();
  static IntPoint* default_instance_;
};
// ===================================================================


// ===================================================================

// Workpackage

// required .gmapping_structs.Particle particle = 1;
inline bool Workpackage::has_particle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Workpackage::set_has_particle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Workpackage::clear_has_particle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Workpackage::clear_particle() {
  if (particle_ != NULL) particle_->::gmapping_structs::Particle::Clear();
  clear_has_particle();
}
inline const ::gmapping_structs::Particle& Workpackage::particle() const {
  return particle_ != NULL ? *particle_ : *default_instance_->particle_;
}
inline ::gmapping_structs::Particle* Workpackage::mutable_particle() {
  set_has_particle();
  if (particle_ == NULL) particle_ = new ::gmapping_structs::Particle;
  return particle_;
}
inline ::gmapping_structs::Particle* Workpackage::release_particle() {
  clear_has_particle();
  ::gmapping_structs::Particle* temp = particle_;
  particle_ = NULL;
  return temp;
}

// repeated double plainreading = 2 [packed = true];
inline int Workpackage::plainreading_size() const {
  return plainreading_.size();
}
inline void Workpackage::clear_plainreading() {
  plainreading_.Clear();
}
inline double Workpackage::plainreading(int index) const {
  return plainreading_.Get(index);
}
inline void Workpackage::set_plainreading(int index, double value) {
  plainreading_.Set(index, value);
}
inline void Workpackage::add_plainreading(double value) {
  plainreading_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Workpackage::plainreading() const {
  return plainreading_;
}
inline ::google::protobuf::RepeatedField< double >*
Workpackage::mutable_plainreading() {
  return &plainreading_;
}

// required bool activeAreaComputed = 3;
inline bool Workpackage::has_activeareacomputed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Workpackage::set_has_activeareacomputed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Workpackage::clear_has_activeareacomputed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Workpackage::clear_activeareacomputed() {
  activeareacomputed_ = false;
  clear_has_activeareacomputed();
}
inline bool Workpackage::activeareacomputed() const {
  return activeareacomputed_;
}
inline void Workpackage::set_activeareacomputed(bool value) {
  set_has_activeareacomputed();
  activeareacomputed_ = value;
}

// required double angularOdometryReliability = 4;
inline bool Workpackage::has_angularodometryreliability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Workpackage::set_has_angularodometryreliability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Workpackage::clear_has_angularodometryreliability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Workpackage::clear_angularodometryreliability() {
  angularodometryreliability_ = 0;
  clear_has_angularodometryreliability();
}
inline double Workpackage::angularodometryreliability() const {
  return angularodometryreliability_;
}
inline void Workpackage::set_angularodometryreliability(double value) {
  set_has_angularodometryreliability();
  angularodometryreliability_ = value;
}

// required double enlargeStep = 5;
inline bool Workpackage::has_enlargestep() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Workpackage::set_has_enlargestep() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Workpackage::clear_has_enlargestep() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Workpackage::clear_enlargestep() {
  enlargestep_ = 0;
  clear_has_enlargestep();
}
inline double Workpackage::enlargestep() const {
  return enlargestep_;
}
inline void Workpackage::set_enlargestep(double value) {
  set_has_enlargestep();
  enlargestep_ = value;
}

// required double freeCellRatio = 6;
inline bool Workpackage::has_freecellratio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Workpackage::set_has_freecellratio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Workpackage::clear_has_freecellratio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Workpackage::clear_freecellratio() {
  freecellratio_ = 0;
  clear_has_freecellratio();
}
inline double Workpackage::freecellratio() const {
  return freecellratio_;
}
inline void Workpackage::set_freecellratio(double value) {
  set_has_freecellratio();
  freecellratio_ = value;
}

// required double fullnessThreshold = 7;
inline bool Workpackage::has_fullnessthreshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Workpackage::set_has_fullnessthreshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Workpackage::clear_has_fullnessthreshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Workpackage::clear_fullnessthreshold() {
  fullnessthreshold_ = 0;
  clear_has_fullnessthreshold();
}
inline double Workpackage::fullnessthreshold() const {
  return fullnessthreshold_;
}
inline void Workpackage::set_fullnessthreshold(double value) {
  set_has_fullnessthreshold();
  fullnessthreshold_ = value;
}

// required double gaussianSigma = 8;
inline bool Workpackage::has_gaussiansigma() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Workpackage::set_has_gaussiansigma() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Workpackage::clear_has_gaussiansigma() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Workpackage::clear_gaussiansigma() {
  gaussiansigma_ = 0;
  clear_has_gaussiansigma();
}
inline double Workpackage::gaussiansigma() const {
  return gaussiansigma_;
}
inline void Workpackage::set_gaussiansigma(double value) {
  set_has_gaussiansigma();
  gaussiansigma_ = value;
}

// required bool generateMap = 9;
inline bool Workpackage::has_generatemap() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Workpackage::set_has_generatemap() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Workpackage::clear_has_generatemap() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Workpackage::clear_generatemap() {
  generatemap_ = false;
  clear_has_generatemap();
}
inline bool Workpackage::generatemap() const {
  return generatemap_;
}
inline void Workpackage::set_generatemap(bool value) {
  set_has_generatemap();
  generatemap_ = value;
}

// required uint32 initialBeamSkip = 10;
inline bool Workpackage::has_initialbeamskip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Workpackage::set_has_initialbeamskip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Workpackage::clear_has_initialbeamskip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Workpackage::clear_initialbeamskip() {
  initialbeamskip_ = 0u;
  clear_has_initialbeamskip();
}
inline ::google::protobuf::uint32 Workpackage::initialbeamskip() const {
  return initialbeamskip_;
}
inline void Workpackage::set_initialbeamskip(::google::protobuf::uint32 value) {
  set_has_initialbeamskip();
  initialbeamskip_ = value;
}

// required int32 kernelSize = 11;
inline bool Workpackage::has_kernelsize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Workpackage::set_has_kernelsize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Workpackage::clear_has_kernelsize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Workpackage::clear_kernelsize() {
  kernelsize_ = 0;
  clear_has_kernelsize();
}
inline ::google::protobuf::int32 Workpackage::kernelsize() const {
  return kernelsize_;
}
inline void Workpackage::set_kernelsize(::google::protobuf::int32 value) {
  set_has_kernelsize();
  kernelsize_ = value;
}

// required double lasamplerange = 12;
inline bool Workpackage::has_lasamplerange() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Workpackage::set_has_lasamplerange() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Workpackage::clear_has_lasamplerange() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Workpackage::clear_lasamplerange() {
  lasamplerange_ = 0;
  clear_has_lasamplerange();
}
inline double Workpackage::lasamplerange() const {
  return lasamplerange_;
}
inline void Workpackage::set_lasamplerange(double value) {
  set_has_lasamplerange();
  lasamplerange_ = value;
}

// required double lasamplestep = 13;
inline bool Workpackage::has_lasamplestep() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Workpackage::set_has_lasamplestep() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Workpackage::clear_has_lasamplestep() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Workpackage::clear_lasamplestep() {
  lasamplestep_ = 0;
  clear_has_lasamplestep();
}
inline double Workpackage::lasamplestep() const {
  return lasamplestep_;
}
inline void Workpackage::set_lasamplestep(double value) {
  set_has_lasamplestep();
  lasamplestep_ = value;
}

// repeated double laserAngles = 14 [packed = true];
inline int Workpackage::laserangles_size() const {
  return laserangles_.size();
}
inline void Workpackage::clear_laserangles() {
  laserangles_.Clear();
}
inline double Workpackage::laserangles(int index) const {
  return laserangles_.Get(index);
}
inline void Workpackage::set_laserangles(int index, double value) {
  laserangles_.Set(index, value);
}
inline void Workpackage::add_laserangles(double value) {
  laserangles_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Workpackage::laserangles() const {
  return laserangles_;
}
inline ::google::protobuf::RepeatedField< double >*
Workpackage::mutable_laserangles() {
  return &laserangles_;
}

// required uint32 laserBeams = 15;
inline bool Workpackage::has_laserbeams() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Workpackage::set_has_laserbeams() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Workpackage::clear_has_laserbeams() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Workpackage::clear_laserbeams() {
  laserbeams_ = 0u;
  clear_has_laserbeams();
}
inline ::google::protobuf::uint32 Workpackage::laserbeams() const {
  return laserbeams_;
}
inline void Workpackage::set_laserbeams(::google::protobuf::uint32 value) {
  set_has_laserbeams();
  laserbeams_ = value;
}

// required double laserMaxRange = 16;
inline bool Workpackage::has_lasermaxrange() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Workpackage::set_has_lasermaxrange() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Workpackage::clear_has_lasermaxrange() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Workpackage::clear_lasermaxrange() {
  lasermaxrange_ = 0;
  clear_has_lasermaxrange();
}
inline double Workpackage::lasermaxrange() const {
  return lasermaxrange_;
}
inline void Workpackage::set_lasermaxrange(double value) {
  set_has_lasermaxrange();
  lasermaxrange_ = value;
}

// required .gmapping_structs.OrientedPoint laserPose = 17;
inline bool Workpackage::has_laserpose() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Workpackage::set_has_laserpose() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Workpackage::clear_has_laserpose() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Workpackage::clear_laserpose() {
  if (laserpose_ != NULL) laserpose_->::gmapping_structs::OrientedPoint::Clear();
  clear_has_laserpose();
}
inline const ::gmapping_structs::OrientedPoint& Workpackage::laserpose() const {
  return laserpose_ != NULL ? *laserpose_ : *default_instance_->laserpose_;
}
inline ::gmapping_structs::OrientedPoint* Workpackage::mutable_laserpose() {
  set_has_laserpose();
  if (laserpose_ == NULL) laserpose_ = new ::gmapping_structs::OrientedPoint;
  return laserpose_;
}
inline ::gmapping_structs::OrientedPoint* Workpackage::release_laserpose() {
  clear_has_laserpose();
  ::gmapping_structs::OrientedPoint* temp = laserpose_;
  laserpose_ = NULL;
  return temp;
}

// required double likelihoodSigma = 18;
inline bool Workpackage::has_likelihoodsigma() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Workpackage::set_has_likelihoodsigma() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Workpackage::clear_has_likelihoodsigma() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Workpackage::clear_likelihoodsigma() {
  likelihoodsigma_ = 0;
  clear_has_likelihoodsigma();
}
inline double Workpackage::likelihoodsigma() const {
  return likelihoodsigma_;
}
inline void Workpackage::set_likelihoodsigma(double value) {
  set_has_likelihoodsigma();
  likelihoodsigma_ = value;
}

// required uint32 likelihoodSkip = 19;
inline bool Workpackage::has_likelihoodskip() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Workpackage::set_has_likelihoodskip() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Workpackage::clear_has_likelihoodskip() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Workpackage::clear_likelihoodskip() {
  likelihoodskip_ = 0u;
  clear_has_likelihoodskip();
}
inline ::google::protobuf::uint32 Workpackage::likelihoodskip() const {
  return likelihoodskip_;
}
inline void Workpackage::set_likelihoodskip(::google::protobuf::uint32 value) {
  set_has_likelihoodskip();
  likelihoodskip_ = value;
}

// required double linearOdometryReliability = 20;
inline bool Workpackage::has_linearodometryreliability() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Workpackage::set_has_linearodometryreliability() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Workpackage::clear_has_linearodometryreliability() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Workpackage::clear_linearodometryreliability() {
  linearodometryreliability_ = 0;
  clear_has_linearodometryreliability();
}
inline double Workpackage::linearodometryreliability() const {
  return linearodometryreliability_;
}
inline void Workpackage::set_linearodometryreliability(double value) {
  set_has_linearodometryreliability();
  linearodometryreliability_ = value;
}

// required double llsamplerange = 21;
inline bool Workpackage::has_llsamplerange() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Workpackage::set_has_llsamplerange() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Workpackage::clear_has_llsamplerange() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Workpackage::clear_llsamplerange() {
  llsamplerange_ = 0;
  clear_has_llsamplerange();
}
inline double Workpackage::llsamplerange() const {
  return llsamplerange_;
}
inline void Workpackage::set_llsamplerange(double value) {
  set_has_llsamplerange();
  llsamplerange_ = value;
}

// required double llsamplestep = 22;
inline bool Workpackage::has_llsamplestep() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Workpackage::set_has_llsamplestep() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Workpackage::clear_has_llsamplestep() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Workpackage::clear_llsamplestep() {
  llsamplestep_ = 0;
  clear_has_llsamplestep();
}
inline double Workpackage::llsamplestep() const {
  return llsamplestep_;
}
inline void Workpackage::set_llsamplestep(double value) {
  set_has_llsamplestep();
  llsamplestep_ = value;
}

// required double optAngularDelta = 23;
inline bool Workpackage::has_optangulardelta() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Workpackage::set_has_optangulardelta() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Workpackage::clear_has_optangulardelta() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Workpackage::clear_optangulardelta() {
  optangulardelta_ = 0;
  clear_has_optangulardelta();
}
inline double Workpackage::optangulardelta() const {
  return optangulardelta_;
}
inline void Workpackage::set_optangulardelta(double value) {
  set_has_optangulardelta();
  optangulardelta_ = value;
}

// required double optLinearDelta = 24;
inline bool Workpackage::has_optlineardelta() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Workpackage::set_has_optlineardelta() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Workpackage::clear_has_optlineardelta() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Workpackage::clear_optlineardelta() {
  optlineardelta_ = 0;
  clear_has_optlineardelta();
}
inline double Workpackage::optlineardelta() const {
  return optlineardelta_;
}
inline void Workpackage::set_optlineardelta(double value) {
  set_has_optlineardelta();
  optlineardelta_ = value;
}

// required uint32 optRecursiveIterations = 25;
inline bool Workpackage::has_optrecursiveiterations() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Workpackage::set_has_optrecursiveiterations() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Workpackage::clear_has_optrecursiveiterations() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Workpackage::clear_optrecursiveiterations() {
  optrecursiveiterations_ = 0u;
  clear_has_optrecursiveiterations();
}
inline ::google::protobuf::uint32 Workpackage::optrecursiveiterations() const {
  return optrecursiveiterations_;
}
inline void Workpackage::set_optrecursiveiterations(::google::protobuf::uint32 value) {
  set_has_optrecursiveiterations();
  optrecursiveiterations_ = value;
}

// required double usableRange = 26;
inline bool Workpackage::has_usablerange() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Workpackage::set_has_usablerange() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Workpackage::clear_has_usablerange() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Workpackage::clear_usablerange() {
  usablerange_ = 0;
  clear_has_usablerange();
}
inline double Workpackage::usablerange() const {
  return usablerange_;
}
inline void Workpackage::set_usablerange(double value) {
  set_has_usablerange();
  usablerange_ = value;
}

// required double minimumScore = 27;
inline bool Workpackage::has_minimumscore() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Workpackage::set_has_minimumscore() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Workpackage::clear_has_minimumscore() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Workpackage::clear_minimumscore() {
  minimumscore_ = 0;
  clear_has_minimumscore();
}
inline double Workpackage::minimumscore() const {
  return minimumscore_;
}
inline void Workpackage::set_minimumscore(double value) {
  set_has_minimumscore();
  minimumscore_ = value;
}

// -------------------------------------------------------------------

// WorkResponse

// required int32 id = 1;
inline bool WorkResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkResponse::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 WorkResponse::id() const {
  return id_;
}
inline void WorkResponse::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .gmapping_structs.IntPoint m_activeArea = 2;
inline int WorkResponse::m_activearea_size() const {
  return m_activearea_.size();
}
inline void WorkResponse::clear_m_activearea() {
  m_activearea_.Clear();
}
inline const ::gmapping_structs::IntPoint& WorkResponse::m_activearea(int index) const {
  return m_activearea_.Get(index);
}
inline ::gmapping_structs::IntPoint* WorkResponse::mutable_m_activearea(int index) {
  return m_activearea_.Mutable(index);
}
inline ::gmapping_structs::IntPoint* WorkResponse::add_m_activearea() {
  return m_activearea_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >&
WorkResponse::m_activearea() const {
  return m_activearea_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >*
WorkResponse::mutable_m_activearea() {
  return &m_activearea_;
}

// required double weight = 3;
inline bool WorkResponse::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorkResponse::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorkResponse::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorkResponse::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double WorkResponse::weight() const {
  return weight_;
}
inline void WorkResponse::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required double weightSum = 4;
inline bool WorkResponse::has_weightsum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorkResponse::set_has_weightsum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorkResponse::clear_has_weightsum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorkResponse::clear_weightsum() {
  weightsum_ = 0;
  clear_has_weightsum();
}
inline double WorkResponse::weightsum() const {
  return weightsum_;
}
inline void WorkResponse::set_weightsum(double value) {
  set_has_weightsum();
  weightsum_ = value;
}

// required .gmapping_structs.OrientedPoint pose = 5;
inline bool WorkResponse::has_pose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WorkResponse::set_has_pose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WorkResponse::clear_has_pose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WorkResponse::clear_pose() {
  if (pose_ != NULL) pose_->::gmapping_structs::OrientedPoint::Clear();
  clear_has_pose();
}
inline const ::gmapping_structs::OrientedPoint& WorkResponse::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::gmapping_structs::OrientedPoint* WorkResponse::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::gmapping_structs::OrientedPoint;
  return pose_;
}
inline ::gmapping_structs::OrientedPoint* WorkResponse::release_pose() {
  clear_has_pose();
  ::gmapping_structs::OrientedPoint* temp = pose_;
  pose_ = NULL;
  return temp;
}

// optional double minx = 6;
inline bool WorkResponse::has_minx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WorkResponse::set_has_minx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WorkResponse::clear_has_minx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WorkResponse::clear_minx() {
  minx_ = 0;
  clear_has_minx();
}
inline double WorkResponse::minx() const {
  return minx_;
}
inline void WorkResponse::set_minx(double value) {
  set_has_minx();
  minx_ = value;
}

// optional double miny = 7;
inline bool WorkResponse::has_miny() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WorkResponse::set_has_miny() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WorkResponse::clear_has_miny() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WorkResponse::clear_miny() {
  miny_ = 0;
  clear_has_miny();
}
inline double WorkResponse::miny() const {
  return miny_;
}
inline void WorkResponse::set_miny(double value) {
  set_has_miny();
  miny_ = value;
}

// optional double maxx = 8;
inline bool WorkResponse::has_maxx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WorkResponse::set_has_maxx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WorkResponse::clear_has_maxx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WorkResponse::clear_maxx() {
  maxx_ = 0;
  clear_has_maxx();
}
inline double WorkResponse::maxx() const {
  return maxx_;
}
inline void WorkResponse::set_maxx(double value) {
  set_has_maxx();
  maxx_ = value;
}

// optional double maxy = 9;
inline bool WorkResponse::has_maxy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WorkResponse::set_has_maxy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WorkResponse::clear_has_maxy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WorkResponse::clear_maxy() {
  maxy_ = 0;
  clear_has_maxy();
}
inline double WorkResponse::maxy() const {
  return maxy_;
}
inline void WorkResponse::set_maxy(double value) {
  set_has_maxy();
  maxy_ = value;
}

// -------------------------------------------------------------------

// Particle

// required uint32 id = 1;
inline bool Particle::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particle::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particle::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particle::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Particle::id() const {
  return id_;
}
inline void Particle::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required double weightSum = 2;
inline bool Particle::has_weightsum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Particle::set_has_weightsum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Particle::clear_has_weightsum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Particle::clear_weightsum() {
  weightsum_ = 0;
  clear_has_weightsum();
}
inline double Particle::weightsum() const {
  return weightsum_;
}
inline void Particle::set_weightsum(double value) {
  set_has_weightsum();
  weightsum_ = value;
}

// required double weight = 3;
inline bool Particle::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Particle::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Particle::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Particle::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double Particle::weight() const {
  return weight_;
}
inline void Particle::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required .gmapping_structs.ScanMatcherMap smap = 4;
inline bool Particle::has_smap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Particle::set_has_smap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Particle::clear_has_smap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Particle::clear_smap() {
  if (smap_ != NULL) smap_->::gmapping_structs::ScanMatcherMap::Clear();
  clear_has_smap();
}
inline const ::gmapping_structs::ScanMatcherMap& Particle::smap() const {
  return smap_ != NULL ? *smap_ : *default_instance_->smap_;
}
inline ::gmapping_structs::ScanMatcherMap* Particle::mutable_smap() {
  set_has_smap();
  if (smap_ == NULL) smap_ = new ::gmapping_structs::ScanMatcherMap;
  return smap_;
}
inline ::gmapping_structs::ScanMatcherMap* Particle::release_smap() {
  clear_has_smap();
  ::gmapping_structs::ScanMatcherMap* temp = smap_;
  smap_ = NULL;
  return temp;
}

// required .gmapping_structs.OrientedPoint pose = 5;
inline bool Particle::has_pose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Particle::set_has_pose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Particle::clear_has_pose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Particle::clear_pose() {
  if (pose_ != NULL) pose_->::gmapping_structs::OrientedPoint::Clear();
  clear_has_pose();
}
inline const ::gmapping_structs::OrientedPoint& Particle::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::gmapping_structs::OrientedPoint* Particle::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::gmapping_structs::OrientedPoint;
  return pose_;
}
inline ::gmapping_structs::OrientedPoint* Particle::release_pose() {
  clear_has_pose();
  ::gmapping_structs::OrientedPoint* temp = pose_;
  pose_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ScanMatcherMap

// required double m_center_x = 1;
inline bool ScanMatcherMap::has_m_center_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanMatcherMap::set_has_m_center_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanMatcherMap::clear_has_m_center_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanMatcherMap::clear_m_center_x() {
  m_center_x_ = 0;
  clear_has_m_center_x();
}
inline double ScanMatcherMap::m_center_x() const {
  return m_center_x_;
}
inline void ScanMatcherMap::set_m_center_x(double value) {
  set_has_m_center_x();
  m_center_x_ = value;
}

// required double m_center_y = 2;
inline bool ScanMatcherMap::has_m_center_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanMatcherMap::set_has_m_center_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanMatcherMap::clear_has_m_center_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanMatcherMap::clear_m_center_y() {
  m_center_y_ = 0;
  clear_has_m_center_y();
}
inline double ScanMatcherMap::m_center_y() const {
  return m_center_y_;
}
inline void ScanMatcherMap::set_m_center_y(double value) {
  set_has_m_center_y();
  m_center_y_ = value;
}

// required double m_worldSizeX = 3;
inline bool ScanMatcherMap::has_m_worldsizex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanMatcherMap::set_has_m_worldsizex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScanMatcherMap::clear_has_m_worldsizex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScanMatcherMap::clear_m_worldsizex() {
  m_worldsizex_ = 0;
  clear_has_m_worldsizex();
}
inline double ScanMatcherMap::m_worldsizex() const {
  return m_worldsizex_;
}
inline void ScanMatcherMap::set_m_worldsizex(double value) {
  set_has_m_worldsizex();
  m_worldsizex_ = value;
}

// required double m_worldSizeY = 4;
inline bool ScanMatcherMap::has_m_worldsizey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanMatcherMap::set_has_m_worldsizey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScanMatcherMap::clear_has_m_worldsizey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScanMatcherMap::clear_m_worldsizey() {
  m_worldsizey_ = 0;
  clear_has_m_worldsizey();
}
inline double ScanMatcherMap::m_worldsizey() const {
  return m_worldsizey_;
}
inline void ScanMatcherMap::set_m_worldsizey(double value) {
  set_has_m_worldsizey();
  m_worldsizey_ = value;
}

// required double m_delta = 5;
inline bool ScanMatcherMap::has_m_delta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScanMatcherMap::set_has_m_delta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScanMatcherMap::clear_has_m_delta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScanMatcherMap::clear_m_delta() {
  m_delta_ = 0;
  clear_has_m_delta();
}
inline double ScanMatcherMap::m_delta() const {
  return m_delta_;
}
inline void ScanMatcherMap::set_m_delta(double value) {
  set_has_m_delta();
  m_delta_ = value;
}

// required int32 m_mapSizeX = 6;
inline bool ScanMatcherMap::has_m_mapsizex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScanMatcherMap::set_has_m_mapsizex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScanMatcherMap::clear_has_m_mapsizex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScanMatcherMap::clear_m_mapsizex() {
  m_mapsizex_ = 0;
  clear_has_m_mapsizex();
}
inline ::google::protobuf::int32 ScanMatcherMap::m_mapsizex() const {
  return m_mapsizex_;
}
inline void ScanMatcherMap::set_m_mapsizex(::google::protobuf::int32 value) {
  set_has_m_mapsizex();
  m_mapsizex_ = value;
}

// required int32 m_mapSizeY = 7;
inline bool ScanMatcherMap::has_m_mapsizey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScanMatcherMap::set_has_m_mapsizey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScanMatcherMap::clear_has_m_mapsizey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScanMatcherMap::clear_m_mapsizey() {
  m_mapsizey_ = 0;
  clear_has_m_mapsizey();
}
inline ::google::protobuf::int32 ScanMatcherMap::m_mapsizey() const {
  return m_mapsizey_;
}
inline void ScanMatcherMap::set_m_mapsizey(::google::protobuf::int32 value) {
  set_has_m_mapsizey();
  m_mapsizey_ = value;
}

// required int32 m_sizeX2 = 8;
inline bool ScanMatcherMap::has_m_sizex2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScanMatcherMap::set_has_m_sizex2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScanMatcherMap::clear_has_m_sizex2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScanMatcherMap::clear_m_sizex2() {
  m_sizex2_ = 0;
  clear_has_m_sizex2();
}
inline ::google::protobuf::int32 ScanMatcherMap::m_sizex2() const {
  return m_sizex2_;
}
inline void ScanMatcherMap::set_m_sizex2(::google::protobuf::int32 value) {
  set_has_m_sizex2();
  m_sizex2_ = value;
}

// required int32 m_sizeY2 = 9;
inline bool ScanMatcherMap::has_m_sizey2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScanMatcherMap::set_has_m_sizey2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScanMatcherMap::clear_has_m_sizey2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScanMatcherMap::clear_m_sizey2() {
  m_sizey2_ = 0;
  clear_has_m_sizey2();
}
inline ::google::protobuf::int32 ScanMatcherMap::m_sizey2() const {
  return m_sizey2_;
}
inline void ScanMatcherMap::set_m_sizey2(::google::protobuf::int32 value) {
  set_has_m_sizey2();
  m_sizey2_ = value;
}

// required .gmapping_structs.HierarchicalArray2D m_storage = 10;
inline bool ScanMatcherMap::has_m_storage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScanMatcherMap::set_has_m_storage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ScanMatcherMap::clear_has_m_storage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ScanMatcherMap::clear_m_storage() {
  if (m_storage_ != NULL) m_storage_->::gmapping_structs::HierarchicalArray2D::Clear();
  clear_has_m_storage();
}
inline const ::gmapping_structs::HierarchicalArray2D& ScanMatcherMap::m_storage() const {
  return m_storage_ != NULL ? *m_storage_ : *default_instance_->m_storage_;
}
inline ::gmapping_structs::HierarchicalArray2D* ScanMatcherMap::mutable_m_storage() {
  set_has_m_storage();
  if (m_storage_ == NULL) m_storage_ = new ::gmapping_structs::HierarchicalArray2D;
  return m_storage_;
}
inline ::gmapping_structs::HierarchicalArray2D* ScanMatcherMap::release_m_storage() {
  clear_has_m_storage();
  ::gmapping_structs::HierarchicalArray2D* temp = m_storage_;
  m_storage_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OrientedPoint

// required double x = 1;
inline bool OrientedPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrientedPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrientedPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrientedPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double OrientedPoint::x() const {
  return x_;
}
inline void OrientedPoint::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool OrientedPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrientedPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrientedPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrientedPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double OrientedPoint::y() const {
  return y_;
}
inline void OrientedPoint::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double theta = 3;
inline bool OrientedPoint::has_theta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrientedPoint::set_has_theta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrientedPoint::clear_has_theta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrientedPoint::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double OrientedPoint::theta() const {
  return theta_;
}
inline void OrientedPoint::set_theta(double value) {
  set_has_theta();
  theta_ = value;
}

// -------------------------------------------------------------------

// PointAccumulator

// required float x = 1;
inline bool PointAccumulator::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointAccumulator::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointAccumulator::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointAccumulator::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointAccumulator::x() const {
  return x_;
}
inline void PointAccumulator::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool PointAccumulator::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointAccumulator::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointAccumulator::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointAccumulator::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointAccumulator::y() const {
  return y_;
}
inline void PointAccumulator::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required int32 n = 3;
inline bool PointAccumulator::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointAccumulator::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointAccumulator::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointAccumulator::clear_n() {
  n_ = 0;
  clear_has_n();
}
inline ::google::protobuf::int32 PointAccumulator::n() const {
  return n_;
}
inline void PointAccumulator::set_n(::google::protobuf::int32 value) {
  set_has_n();
  n_ = value;
}

// required int32 visits = 4;
inline bool PointAccumulator::has_visits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointAccumulator::set_has_visits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointAccumulator::clear_has_visits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointAccumulator::clear_visits() {
  visits_ = 0;
  clear_has_visits();
}
inline ::google::protobuf::int32 PointAccumulator::visits() const {
  return visits_;
}
inline void PointAccumulator::set_visits(::google::protobuf::int32 value) {
  set_has_visits();
  visits_ = value;
}

// -------------------------------------------------------------------

// Array2D_innerType

// repeated .gmapping_structs.PointAccumulator y = 1;
inline int Array2D_innerType::y_size() const {
  return y_.size();
}
inline void Array2D_innerType::clear_y() {
  y_.Clear();
}
inline const ::gmapping_structs::PointAccumulator& Array2D_innerType::y(int index) const {
  return y_.Get(index);
}
inline ::gmapping_structs::PointAccumulator* Array2D_innerType::mutable_y(int index) {
  return y_.Mutable(index);
}
inline ::gmapping_structs::PointAccumulator* Array2D_innerType::add_y() {
  return y_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::PointAccumulator >&
Array2D_innerType::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::PointAccumulator >*
Array2D_innerType::mutable_y() {
  return &y_;
}

// -------------------------------------------------------------------

// Array2D

// required int32 m_xsize = 1;
inline bool Array2D::has_m_xsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Array2D::set_has_m_xsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Array2D::clear_has_m_xsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Array2D::clear_m_xsize() {
  m_xsize_ = 0;
  clear_has_m_xsize();
}
inline ::google::protobuf::int32 Array2D::m_xsize() const {
  return m_xsize_;
}
inline void Array2D::set_m_xsize(::google::protobuf::int32 value) {
  set_has_m_xsize();
  m_xsize_ = value;
}

// required int32 m_ysize = 2;
inline bool Array2D::has_m_ysize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Array2D::set_has_m_ysize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Array2D::clear_has_m_ysize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Array2D::clear_m_ysize() {
  m_ysize_ = 0;
  clear_has_m_ysize();
}
inline ::google::protobuf::int32 Array2D::m_ysize() const {
  return m_ysize_;
}
inline void Array2D::set_m_ysize(::google::protobuf::int32 value) {
  set_has_m_ysize();
  m_ysize_ = value;
}

// repeated .gmapping_structs.Array2D.innerType x = 4;
inline int Array2D::x_size() const {
  return x_.size();
}
inline void Array2D::clear_x() {
  x_.Clear();
}
inline const ::gmapping_structs::Array2D_innerType& Array2D::x(int index) const {
  return x_.Get(index);
}
inline ::gmapping_structs::Array2D_innerType* Array2D::mutable_x(int index) {
  return x_.Mutable(index);
}
inline ::gmapping_structs::Array2D_innerType* Array2D::add_x() {
  return x_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Array2D_innerType >&
Array2D::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Array2D_innerType >*
Array2D::mutable_x() {
  return &x_;
}

// -------------------------------------------------------------------

// Autoptr

// optional .gmapping_structs.Array2D data = 1;
inline bool Autoptr::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Autoptr::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Autoptr::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Autoptr::clear_data() {
  if (data_ != NULL) data_->::gmapping_structs::Array2D::Clear();
  clear_has_data();
}
inline const ::gmapping_structs::Array2D& Autoptr::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::gmapping_structs::Array2D* Autoptr::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::gmapping_structs::Array2D;
  return data_;
}
inline ::gmapping_structs::Array2D* Autoptr::release_data() {
  clear_has_data();
  ::gmapping_structs::Array2D* temp = data_;
  data_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// HierarchicalArray2D_innerType

// repeated .gmapping_structs.Autoptr m_cells_y = 1;
inline int HierarchicalArray2D_innerType::m_cells_y_size() const {
  return m_cells_y_.size();
}
inline void HierarchicalArray2D_innerType::clear_m_cells_y() {
  m_cells_y_.Clear();
}
inline const ::gmapping_structs::Autoptr& HierarchicalArray2D_innerType::m_cells_y(int index) const {
  return m_cells_y_.Get(index);
}
inline ::gmapping_structs::Autoptr* HierarchicalArray2D_innerType::mutable_m_cells_y(int index) {
  return m_cells_y_.Mutable(index);
}
inline ::gmapping_structs::Autoptr* HierarchicalArray2D_innerType::add_m_cells_y() {
  return m_cells_y_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Autoptr >&
HierarchicalArray2D_innerType::m_cells_y() const {
  return m_cells_y_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::Autoptr >*
HierarchicalArray2D_innerType::mutable_m_cells_y() {
  return &m_cells_y_;
}

// -------------------------------------------------------------------

// HierarchicalArray2D

// required int32 m_patchMagnitude = 1;
inline bool HierarchicalArray2D::has_m_patchmagnitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HierarchicalArray2D::set_has_m_patchmagnitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HierarchicalArray2D::clear_has_m_patchmagnitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HierarchicalArray2D::clear_m_patchmagnitude() {
  m_patchmagnitude_ = 0;
  clear_has_m_patchmagnitude();
}
inline ::google::protobuf::int32 HierarchicalArray2D::m_patchmagnitude() const {
  return m_patchmagnitude_;
}
inline void HierarchicalArray2D::set_m_patchmagnitude(::google::protobuf::int32 value) {
  set_has_m_patchmagnitude();
  m_patchmagnitude_ = value;
}

// required int32 m_patchSize = 2;
inline bool HierarchicalArray2D::has_m_patchsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HierarchicalArray2D::set_has_m_patchsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HierarchicalArray2D::clear_has_m_patchsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HierarchicalArray2D::clear_m_patchsize() {
  m_patchsize_ = 0;
  clear_has_m_patchsize();
}
inline ::google::protobuf::int32 HierarchicalArray2D::m_patchsize() const {
  return m_patchsize_;
}
inline void HierarchicalArray2D::set_m_patchsize(::google::protobuf::int32 value) {
  set_has_m_patchsize();
  m_patchsize_ = value;
}

// repeated .gmapping_structs.HierarchicalArray2D.innerType m_cells_x = 3;
inline int HierarchicalArray2D::m_cells_x_size() const {
  return m_cells_x_.size();
}
inline void HierarchicalArray2D::clear_m_cells_x() {
  m_cells_x_.Clear();
}
inline const ::gmapping_structs::HierarchicalArray2D_innerType& HierarchicalArray2D::m_cells_x(int index) const {
  return m_cells_x_.Get(index);
}
inline ::gmapping_structs::HierarchicalArray2D_innerType* HierarchicalArray2D::mutable_m_cells_x(int index) {
  return m_cells_x_.Mutable(index);
}
inline ::gmapping_structs::HierarchicalArray2D_innerType* HierarchicalArray2D::add_m_cells_x() {
  return m_cells_x_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::HierarchicalArray2D_innerType >&
HierarchicalArray2D::m_cells_x() const {
  return m_cells_x_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::HierarchicalArray2D_innerType >*
HierarchicalArray2D::mutable_m_cells_x() {
  return &m_cells_x_;
}

// required int32 m_xsize = 4;
inline bool HierarchicalArray2D::has_m_xsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HierarchicalArray2D::set_has_m_xsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HierarchicalArray2D::clear_has_m_xsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HierarchicalArray2D::clear_m_xsize() {
  m_xsize_ = 0;
  clear_has_m_xsize();
}
inline ::google::protobuf::int32 HierarchicalArray2D::m_xsize() const {
  return m_xsize_;
}
inline void HierarchicalArray2D::set_m_xsize(::google::protobuf::int32 value) {
  set_has_m_xsize();
  m_xsize_ = value;
}

// required int32 m_ysize = 5;
inline bool HierarchicalArray2D::has_m_ysize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HierarchicalArray2D::set_has_m_ysize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HierarchicalArray2D::clear_has_m_ysize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HierarchicalArray2D::clear_m_ysize() {
  m_ysize_ = 0;
  clear_has_m_ysize();
}
inline ::google::protobuf::int32 HierarchicalArray2D::m_ysize() const {
  return m_ysize_;
}
inline void HierarchicalArray2D::set_m_ysize(::google::protobuf::int32 value) {
  set_has_m_ysize();
  m_ysize_ = value;
}

// repeated .gmapping_structs.IntPoint m_activeArea = 6;
inline int HierarchicalArray2D::m_activearea_size() const {
  return m_activearea_.size();
}
inline void HierarchicalArray2D::clear_m_activearea() {
  m_activearea_.Clear();
}
inline const ::gmapping_structs::IntPoint& HierarchicalArray2D::m_activearea(int index) const {
  return m_activearea_.Get(index);
}
inline ::gmapping_structs::IntPoint* HierarchicalArray2D::mutable_m_activearea(int index) {
  return m_activearea_.Mutable(index);
}
inline ::gmapping_structs::IntPoint* HierarchicalArray2D::add_m_activearea() {
  return m_activearea_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >&
HierarchicalArray2D::m_activearea() const {
  return m_activearea_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmapping_structs::IntPoint >*
HierarchicalArray2D::mutable_m_activearea() {
  return &m_activearea_;
}

// -------------------------------------------------------------------

// IntPoint

// required int32 x = 1;
inline bool IntPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 IntPoint::x() const {
  return x_;
}
inline void IntPoint::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool IntPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 IntPoint::y() const {
  return y_;
}
inline void IntPoint::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gmapping_structs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protobuf_2fparticle_5freading_2eproto__INCLUDED
